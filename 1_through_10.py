import numpy as np
from time import time
import math


#1
def sum_factors_below_n(factors,n):
    """
    If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

    Find the sum of all the multiples of 3 or 5 below 1000.

    """
    outputs = []
    for factor in factors:
        if n/factor == n//factor:
            lim = int(n/factor)
            facrange = list(range(lim))

        else:
            lim = n//factor
            print(lim)
            facrange = list(range(lim+1))

        for num in facrange:
            outputs.append(num*factor)

    return sum(set(outputs))


sum_factors_below_n([3,5],1000)





#2
def fibs(n):
    """Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

    By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms."""
    fibslist = [1,2]
    while fibslist[-2] < n:
        fibslist.append(fibslist[-1] + fibslist[-2])

    fibevens = 0

    for fub in fibslist:
        if fub % 2 ==0:
            fibevens += fub

    return fibevens



fibs(4*10e5)




#3
def prime_num_list(n):

    nums = [3]
    for i in range(5,n,2):
        prime = 1
        for num in nums:
            if prime == 1:
                if i % num == 0:
                    prime=0
        if prime ==1:
            nums.append(i)
    return nums



def prime_facs_very_slow(n):
    primes=prime_num_list(n)
    for num in primes[::-1]:
        if n % num == 0:
            return num


def prime_facs_good(n):
        """
        The prime factors of 13195 are 5, 7, 13 and 29.

        What is the largest prime factor of the number 600851475143 ?"""
    limit = int(np.around(np.sqrt(n), decimals=0))
    for num in range(limit-1,2,-1):
        if n % num == 0:
            factor = num
            prime = 1
            for tester in range(2,factor):
                if prime == 1:
                    if factor % tester == 0:
                        prime =0
                        break
            if prime==1:
                return factor


factor = prime_facs_good(600851475143)

print(factor)


#4
"""
A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.

Find the largest palindrome made from the product of two 3-digit numbers."""



def find_palindrome(n):
    possibilities = []
    for num1 in range(n-1,0,-1):
        # print('num1',num1)
        for num2 in range(n-1,0,-1):
            # print('num2',num2)
            product = num1*num2
            if str(product) == ''.join(list(str(product))[::-1]):
              possibilities.append(product)
    return max(possibilities)



print(find_palindrome(1000))



#5

"""2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.

What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"""



def check_if_divisible(n):

    numlist = list(range(2,n+1))

    numcheck = n
    is_solution = False
    while (is_solution == False):
        if all(numcheck % num == 0 for num in numlist):
            is_solution=True
            return numcheck
        else:
            numcheck +=n

               # if all(attempt % prime != 0 for prime in primes):

check_if_divisible(20)




def prime_facs_good(n):
    """
    The prime factors of 13195 are 5, 7, 13 and 29.

    What is the largest prime factor of the number 600851475143 ?"""
    limit = int(np.around(np.sqrt(n), decimals=0))
    for num in range(limit-1,2,-1):
        if n % num == 0:
            factor = num
            prime = 1
            for tester in range(2,factor):
                if prime == 1:
                    if factor % tester == 0:
                        prime =0
                        break
            if prime==1:
                return factor

prime_facs_good(100)




"""
number 6


The sum of the squares of the first ten natural numbers is,

1^2 + 2^2 + ... + 10^2 = 385

The square of the sum of the first ten natural numbers is,

(1 + 2 + ... + 10)^2 = 552 = 3025

Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.

Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.

"""





def sum_of_squares(n):
    summation = 0
    for number in range(1,n+1):
        summation += np.square(number)
    return summation

def square_of_sum(n):
    summation = np.sum(range(1,n+1))
    return np.square(summation)

def difference_of_sums(n):

    return square_of_sum(n) - sum_of_squares(n)


difference_of_sums(100)


#7
"""

By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.

What is the 10 001st prime number?
"""

def list_primes(n):
    starttime=time()
    primelist = [2,3]
    i = 5
    while len(primelist) < n:
        is_prime=1
        limit = int(np.around(np.sqrt(i), decimals=0))
        for testnum in range(3,limit+1,2):
            if is_prime==1:
                if i % testnum ==0:
                    is_prime=0
                    continue

        if is_prime==1:
            primelist.append(i)
        i+=2

    print(time()-starttime)
    return primelist



primeline = list_primes(10001)


len(primeline)
primeline[:10]
primeline[-10:]
primeline[-1]


#
# #from github, using sieve of erasthenes
# def primes_sieve(n):
#     starttime=time()
#     p_n = int(2 * n * math.log(n))       # over-estimate p_n
#     sieve = [True] * p_n                 # everything is prime to start
#     count = 0
#     for i in range(2, p_n):
#         if sieve[i]:                       # still prime?
#             count += 1                     # count it!
#             if count == n:
#                 print(time()-starttime)                 # done!
#                 return i
#             for j in range(2*i, p_n, i):   # cross off all multiples of i
#                 sieve[j] = False
#
# primes_sieve(10001)



#8
"""
The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.


Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?

"""


longnum = 7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450
def string_number(n):
    return [int(i) for i in str(n)]



def find_top_product(n,digit_lim):

    top_product = 0

    n_list = string_number(n)

    for ind,el in enumerate(n_list):
        if (ind <= len(n_list) - digit_lim):
            current_product = np.prod(n_list[ind:ind+digit_lim])
            if current_product > top_product:
                top_product=current_product
    return top_product


find_top_product(longnum,13)

#9
"""
A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,

a2 + b2 = c2
For example, 32 + 42 = 9 + 16 = 25 = 52.

There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc.
"""

def check_is_triplet(a,b):

    checknum = np.sqrt(np.square(a) + np.square(b))
    if np.around(checknum,decimals=0) == checknum:
        return True
    return False




check_is_triplet(3,4)

def find_pythagorean_triplet(n):
    for a in range(2,n):
        for b in range(2,n-a):
            checknum = np.sqrt(np.square(a) + np.square(b))
            if np.around(checknum,decimals=0) == checknum:
                if a + b + checknum == n:
                    return a * b * checknum,a,b,checknum

np.sum([16, 63, 65])
find_pythagorean_triplet(1000)


#10
"""
The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
Find the sum of all the primes below two million.
"""

def primes_sieve(n):
    starttime=time()
    p_n = int(n)
    sieve = [True] * p_n                 # everything is prime to start
    for i in range(0,2):
        sieve[i] = False
    for i in range(2, p_n):
        if sieve[i]:                       # still prime?
            for j in range(2*i, p_n, i):   # cross off all multiples of i
                sieve[j] = False
    print(time()- starttime)
    return sieve

def find_remaining_primes(n):
    sum = 0
    sievelist = primes_sieve(n)
    for i in range(len(sievelist)):
        if sievelist[i]:
            sum+=i
    return sum





find_remaining_primes(2e6)
